{"meta":{"title":"LiZhongXiao","subtitle":"","description":"","author":"LiZhongXiao","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Handler解析","slug":"Handler解析","date":"2021-03-14T08:15:16.254Z","updated":"2021-03-14T08:36:17.861Z","comments":true,"path":"2021/03/14/Handler解析/","link":"","permalink":"http://example.com/2021/03/14/Handler%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Hnadler机制基本流程： Handler机制相关类类的基本作用· Handler：用于发送也接收消息· Message：消息实体· Looper：用于轮询消息队列，一个线程只有一个Looper· MessageQueue：消息队列，用于存储消息和管理消息 Handler先来看一下Handler的构造方法，根据是否传入Looper，最后会执行到两个不同的构造方法 构造1： 12345678910111213141516171819202122public Handler(@Nullable Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; //设置是否同步处理消息，默认为false &#125; 该构造中因为没有传入Looper，所以要从Looper中的ThreadLocal静态常量中获取获取当前线程的Looper（ThreadLocal中的ThreadLocalMap保存着Looper），如果当前线程没有Looper，或者说当前线程的Looper没有prepare，则直接抛出异常。 构造2： 1234567public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; Handler各种发送message方法最后都会归并到enqueueMessage()函数中，将message加入队列中 12345678910private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; 此处Handler会将自身设置为Message的target参数变量 msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; //判断handler处理方式，设置Message的flag msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 构建Message的obtainMessage方法中使用Message的obtain方法初始化Message相关参数，此处同样会将Handler自身传入Message中，这也是为什么Handler会造成内存泄漏的地方，因为Message持有了handler，如果当Message被设置为10分钟后执行则持有Handler的对象10分钟内则无法被回收。 123public final Message obtainMessage(int what, int arg1, int arg2, @Nullable Object obj) &#123; return Message.obtain(this, what, arg1, arg2, obj); &#125; 处理接收数据的handleMessage 123456789101112public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; Handler中有一个静态内部类BlockingRunnable 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static final class BlockingRunnable implements Runnable &#123; private final Runnable mTask; private boolean mDone; public BlockingRunnable(Runnable task) &#123; mTask = task; &#125; @Override public void run() &#123; try &#123; mTask.run(); &#125; finally &#123; synchronized (this) &#123; mDone = true; notifyAll(); &#125; &#125; &#125; public boolean postAndWait(Handler handler, long timeout) &#123; if (!handler.post(this)) &#123; return false; &#125; synchronized (this) &#123; if (timeout &gt; 0) &#123; final long expirationTime = SystemClock.uptimeMillis() + timeout; while (!mDone) &#123; long delay = expirationTime - SystemClock.uptimeMillis(); if (delay &lt;= 0) &#123; return false; // timeout &#125; try &#123; wait(delay);//限时等待 &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; else &#123; while (!mDone) &#123; try &#123; wait(); //无限期等待 &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; &#125; return true; &#125; &#125; 用于实现Handler发送同步消息，既发送消息的线程在发送消息后处于休眠状态，等待消息回调后唤醒。在 Runnable 执行完前会通过调用 wait()方法来使发送者线程转为阻塞等待状态，当任务执行完毕后再通过notifyAll()来唤醒发送者线程，从而实现了在 Runnable 被执行完之前发送者线程都会一直处于等待状态 该Runnable只在runWithScissors方法中使用，而runWithScissors是隐藏函数(@hide) 此处的等待要和后续提到的Looper等待区分开 Message1234567891011121314151617181920212223242526272829303132333435public final class Message implements Parcelable &#123; public int what; public int arg1; public int arg2; public Object obj; public Messenger replyTo; public static final int UID_NONE = -1; public int sendingUid = UID_NONE; public int workSourceUid = UID_NONE; static final int FLAG_IN_USE = 1 &lt;&lt; 0; static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1; static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; @UnsupportedAppUsage //不受限制的灰名单 int flags; @UnsupportedAppUsage @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE) public long when; Bundle data; @UnsupportedAppUsage Handler target; @UnsupportedAppUsage Runnable callback; @UnsupportedAppUsage Message next; /** @hide */ public static final Object sPoolSync = new Object(); private static Message sPool; private static int sPoolSize = 0; private static final int MAX_POOL_SIZE = 50;//链表最大值 private static boolean gCheckRecycle = true; ...&#125; Message类就是消息载体，本质可以理解为一个单链表结构的节点，实现了Parcelable接口，使得它可以序列化和反序列化。 1234567891011121314151617181920212223242526272829303132333435363738public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; sPoolSize--; return m; &#125; &#125; return new Message(); &#125; ......@UnsupportedAppUsage void recycleUnchecked() &#123; flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123;//当前链表size小于最大值时将回收的Message放入pool next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; Message的创建会先从回收的pool中获取，如果pool为空则新建一个。Message自身实现了回收方法，用于Message对象的回收再利用，防止内存溢出、内存抖动（享元模式） Looper1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public final class Looper &#123; private static final String TAG = &quot;Looper&quot;; @UnsupportedAppUsage static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); @UnsupportedAppUsage private static Looper sMainLooper;//主线程的Looper private static Observer sObserver; @UnsupportedAppUsage final MessageQueue mQueue; 消息队列 final Thread mThread; @UnsupportedAppUsage private Printer mLogging; private long mTraceTag; //如果设置了此选项，则如果消息调度的时间超过此值，循环器将显示警告日志。 private long mSlowDispatchThresholdMs; //如果设置，如果消息传递（实际传递时间-发布时间）花费的时间超过此时间，循环器将显示警告日志。 private long mSlowDeliveryThresholdMs; public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; //此方法创建主线的looper，如果重复调用会抛出异常， public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125; ...... private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; ...... public void quit() &#123; mQueue.quit(false); &#125; public void quitSafely() &#123; mQueue.quit(true); &#125;&#125; 可以看到Looper的构造方法是私有的，创建Looper需要通过prepare方法，quitAllowed字段用于标识消息队列是否可以主动清空操作。此外，sThreadLocal和sMainLooper都是静态常量，可以理解为全局只有一个sThreadLocal和sMainLooper，prepareMainLooper方法会在ActivityThread中被调用，所以正常使用时调用prepareMainLooper会抛出异常，保证主线程Looper的唯一性。 接下来看一下Looper的核心工作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; //首先判断Looper是否初始化 throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; ...... for (;;) &#123; //死循环从队列里获取消息 Message msg = queue.next(); // might block if (msg == null) &#123;//如果msg为空说明queue调用了上述的quit方法，队列已经被清空，退出循环遍历。 return; &#125; ...... final Observer observer = sObserver; final long traceTag = me.mTraceTag; 跟踪标识，将跟踪事件写入系统跟踪缓冲区。这些跟踪事件可以使用Systrace工具进行收集和可视化 ...... if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg); //此处的target就是上述提到的msg构建时将自身传入msg的handler。 if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ..... msg.recycleUnchecked();//回收msg对象，具体实现已在上述Message介绍中给出。 &#125; &#125; MessageQueue可以看到Looper只是循环的拿数据分发出去，而消息的各种处理，比如延时消息处理，同步屏障处理等则主要在MessageQueue中实现 首先看一下上面提到的入队函数enqueueMessage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123;//没有绑定handler，抛出异常 throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123;//该message对象已经入队，抛出异常 throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123;//消息队列已经quit，代表以及无法处理消息，抛出异常 IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; //是否唤起 if (p == null || when == 0 || when &lt; p.when) &#123;//如果原本Message链表队头为空，或者when=0，或者when小于当前队头，则直接将入队的message设为队头。 msg.next = p; mMessages = msg; needWake = mBlocked; //mBlocked是否阻塞了Looper的轮询，会在后续的next方法中设置为true/false，如果为true则说明Looper需要唤醒 &#125; else &#123; //根据when进行拆入排序 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); //唤醒Looper，mPtr是native层中MessageQueue对象的引用地址 &#125; &#125; return true; &#125;//android_os_MessageQueue.cpp中nativeWake的调用流程static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125; void NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125; //Looper.cpp void Looper::wake() &#123;//往mWakeEventFd中write 1唤醒 uint64_t inc = 1; ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t)));&#125; enqueueMessage方法主要实现了消息的插入排序后入队，此处还会根据needWake字段，判断是否调用native的方法唤醒Looper，而Looper的休眠则是在后面next方法中nativePollOnce中实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; //quit后会将mPtr赋值为0 return null; &#125; int pendingIdleHandlerCount = -1; int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //nextPollTimeoutMillis为等待事件，-1时则无限等待 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 如果队头Message得到target为null，遍历队列，如果存在同步消息则立刻执行（同步屏障） do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123;//如果消息还没到时间则计算出时间差，循环到上面的nativePollOnce方法让Looper开始等待 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; msg.markInUse(); return msg; &#125; &#125; else &#123; nextPollTimeoutMillis = -1; &#125; // 此处dispose会将mPtr置为0 if (mQuitting) &#123; dispose(); return null; &#125; //后面主要是在没消息空闲时设置IdleHandler了的逻辑 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; //没有消息也没设置IdleHandler则阻塞 mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; &#125; &#125; //android_os_MessageQueue.cpp static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis); &#125; void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; ...... mLooper-&gt;pollOnce(timeoutMillis); ...... &#125; //Looper.cpp int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; ...... result = pollInner(timeoutMillis); ...... &#125; int Looper::pollInner(int timeoutMillis) &#123; ...... //使用epoll_wait进行等待，timeoutMillis就是等待的时间 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); ...... &#125; 在这个next方法中主要做了一下几点事情：· 获取一个Message，如果存在同步屏障（target为null的Message）则说明存在需要立刻执行的Message，遍历找到消息后立刻执行，具体插入屏障的方法postSyncBarrier（应用：view的刷新ViewRootImpl.java）。· 遍历完取得一个Message后计算消息是否已经到了可执行时间，没有则计算出nextPollTimeoutMillis，利用nativePollOnce方法让Looper进行等待。· 如果当前没有消息处理，则判断是否有IdleHandler，IdleHandler 主要用在我们希望能够在当前线程 消息队列空闲时 做些事情（例如UI线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。使用场景： 1234567Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; //do somethings return false; &#125;&#125;); · 如果已经调用quit，调用dispose方法销毁native中的MessageQueue 123456private void dispose() &#123; if (mPtr != 0) &#123; nativeDestroy(mPtr); mPtr = 0; &#125; &#125; 思考· 一个线程有几个 Looper？· Handler 内存泄漏原因？· Looper死循环为什么不会导致应用卡死？（Choreographer.java）· HnadlerThread是什么？创建子线程的Handler： 12345678910111213141516171819202122232425262728Handler handler; //全局变量 private void testThread()&#123; Thread thread = new Thread(new Runnable() &#123; Looper looper; @Override public void run() &#123; Looper.prepare(); looper = Looper.myLooper(); handler = new Handler(looper); Looper.loop(); &#125; &#125;); thread.start(); //Handler handler = new Handler(thread.getLooper()); //Thread并没有getLooper() &#125; private void testHandlerThread()&#123; HandlerThread handlerThread = new HandlerThread(&quot;testHandlerThread&quot;); handlerThread.start(); Handler handler = new Handler(handlerThread.getLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; //do something &#125; &#125;); &#125; 优点：· 方便初始化，方便获取Looper· 保证线程安全","categories":[],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://example.com/tags/Handler/"},{"name":"Message","slug":"Message","permalink":"http://example.com/tags/Message/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-03-13T14:45:26.284Z","updated":"2021-03-13T14:45:26.284Z","comments":true,"path":"2021/03/13/hello-world/","link":"","permalink":"http://example.com/2021/03/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://example.com/tags/Handler/"},{"name":"Message","slug":"Message","permalink":"http://example.com/tags/Message/"}]}